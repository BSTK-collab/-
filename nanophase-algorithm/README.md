兴趣推荐算法简易逻辑：
假设是一个新注册用户，可以根据选中的兴趣标签推荐热门内容（大家都爱看的）
给这些热门内容设置较高的随机值，假设为0.7，但是保留较低的随机值推荐其他内容，作为开阔信息范围
假设非用户主动搜索的内容，随机值为0.1 ~ 0.2；而用户主动搜索的随机值提高为0.4 ~ 0.5
随着用户非主动搜索的自动推荐的内容，根据点击量动态更新该内容对应的随机值，及调高或调低随机值
（为了保证推荐内容的广泛性，可以设置最低推荐值永远大于0，根据业务设置）
随着用户主动搜索的自动推荐内容，根据点击量动态更新随机值
同时普通热门内容与选中的兴趣标签同样根据推荐的点击量更新推荐值

CPU密集型：大量for循环之类，密集使用CPU
io密集型：大量的拷贝等io操作
线程数设置多少合适？
N(thread) = N(CPU) * U(CPU) * (1 + W/C)
N(CPU)是CPU的核数，Runtime.getRuntime.availableProcessors()得到
U(CPU)是期望的CPU利用率，应该会介于0-1之间
W/C等待时间与计算时间的比率
如何优雅的结束一个线程？
上传大文件时，由于消耗时间较大，那么点击取消时，如何优雅的结束：
并发编程的三大特性：
1，可见性(Visibility)
2，有序性(ordering)
3，原子性(atomicity)
从cpu的计算单元(ALU)到
L1 cache ≈ 1ns
L2 cache ≈ 3ns
L3 cache ≈ 15ns
main memory ≈ 80ns
多个CPU：
CPU => 包含多个核，每个核有自己的一二级高速缓存，第三级缓存 在CPU级别
内存在CPU外，我们说的线程的缓存一般都是三级缓存
空间局部性原理提升性能：
该原理认为读取一个值的时候大概率会用到周边的值，所以一次性会把周边的值都取过来
将一整块数据读到内存，如同数组，取了第一个值，可能其他的值也读取了过来，每次读取一整块的数据叫做缓存行

一个缓存行的大小是64字节
时间局部性则是读取指令